# Absolute Resolver — Spec v2 (Improved Architecture)

## Input (must be provided)

* `NOW_ISO` (ISO with numeric offset, e.g., `2025-10-18T15:00:00-04:00`)
* `TIMEZONE` (IANA, e.g., `America/New_York`)
* **Helpers** (all as strings in the same canonical format where applicable):

  * `TODAY_HUMAN` (e.g., `Saturday, October 18, 2025`)
  * `END_OF_TODAY` (e.g., `October 18, 2025 11:59 pm`)
  * `END_OF_WEEK` (Sun 11:59 pm of current week)
  * `END_OF_MONTH` (EOM 11:59 pm)
  * `NEXT_MONDAY` (next Monday 09:00 am anchor for "next week")
  * `NEXT_OCCURRENCES` for weekdays (`Monday`…`Sunday`, values like `October 24, 2025`)
* **Slots** from the Slot Extractor:

  ```json
  {"start_text": string|null, "end_text": string|null, "duration": string|null}
  ```

## Output (STRICT JSON)

```json
{
  "start_text": "Month DD, YYYY HH:MM am/pm",
  "end_text":   "Month DD, YYYY HH:MM am/pm",
  "duration":   "2h" | "45m" | null
}
```

* Use **exact** canonical format: `"Month DD, YYYY HH:MM am/pm"`.
* Copy `duration` **as-is** (do not convert or use it to move start/end).

---

## NEW ARCHITECTURE (Key Change)

**IMPORTANT:** Only `start_text` and `end_text` are passed to the LLM for processing. `duration` is handled separately and attached to the output unchanged.

### Processing Flow:
1. **Input**: Slots from Slot Extractor `{"start_text": "...", "end_text": "...", "duration": "..."}`
2. **LLM Processing**: Only `{"start_text": "...", "end_text": "..."}` sent to LLM
3. **LLM Output**: `{"start_text": "resolved...", "end_text": "resolved..."}`
4. **Final Output**: Attach original `duration` to LLM output

### Why This Change:
- **Eliminates confusion**: LLM cannot accidentally use duration for calculations
- **Prevents errors**: No more duration-based start/end time calculations
- **Cleaner processing**: Separation of concerns between time resolution and metadata
- **Deterministic**: More predictable behavior

---

## Core principles

* **Determinism:** Always produce one specific calendar date/time for both `start_text` and `end_text`.
* **Duration is metadata:** Never shift `start_text` or `end_text` because of duration.
* **Safety:** Always ensure `start ≤ end`. If not, repair deterministically.
* **Separation of concerns:** Process only `start_text` and `end_text`; handle `duration` separately.

---

## Resolution rules (from Slots → Absolute)

### 1) If **both** `start_text` and `end_text` are present

* Treat as a **window** with a start anchor and an end anchor.
* Resolve each side to an absolute datetime.
* If one/both sides specify **only times** (no date), attach them to the **same resolved date**.
* **Cross-midnight rule:** if resolved `end < start`, move `end` forward **1 day**.

### 2) If **only** `end_text` is present (deadline)

* **Start** = `NOW_ISO` expressed in canonical format.
* **End** = resolved deadline; if it has **no time**, set to **11:59 pm** on that date.
* If `end < start`, move `end` to the **next plausible occurrence**.

### 3) If **only** `start_text` is present (start-only)

* **Start** = resolved start anchor.
* **End** = **11:59 pm on the SAME DATE as the resolved start**.
* If start time is < today, push both start and end to next day.

### 4) If **neither** is present

* **Start** = `NOW_ISO` (canonical format), **End** = `END_OF_TODAY`.

---

## Phrase resolution details

### Weekday resolution (deterministic)

* Unqualified weekday (e.g., "Friday"): choose the **next occurrence** (or **today** if it hasn't passed yet).
* "this Friday" → Friday **of the current week**.
* "next Friday" → Friday **of the following week**.

### Bare times (no date)

* If the time **today** is **after or equal** to `NOW`, schedule for **today**.
* If the time **today** is **already past**, schedule for **tomorrow**.
* When both sides are bare times → put both on the **same inferred date**.

### Vague periods (default anchors)

* morning → 09:00
* afternoon → 13:00
* evening → 18:00
* tonight → 20:00
* noon → 12:00
* midnight → 00:00
* **tomorrow (without time) → 12:00 am (midnight) of next day** ⭐ **FIXED**

### "midnight" disambiguation

* "**midnight Friday**" → 00:00 at the **start of Friday**.
* "**Friday midnight**" → 00:00 at the **start of Saturday**.

### "next week" / "this week"

* "next week" (as start-only) → **NEXT_MONDAY 12:00 am**.
* "end of week" (deadline) → **END_OF_WEEK 11:59 pm**.

### Month/period endings

* "by EOM" / "end of month" (deadline) → **END_OF_MONTH 11:59 pm**.

---

## Safety & repairs

* **Always ensure** `start ≤ end`.
* If violated after resolution, set `end` = **11:59 pm on start's date**.
* Do **not** invent times other than the specified anchors.

---

## Duration handling (COMPLETELY SEPARATED)

* **Duration is NEVER sent to the LLM**
* Copy `duration` straight through **unchanged**
* Do **not** compute `start = end − duration` or `end = start + duration`
* Do **not** process or modify duration values
* Do **not** use duration to calculate or adjust start/end times
* Duration is metadata only - pass it through unchanged

---

## Examples (assume NOW = `2025-10-18T15:00:00-04:00`, TZ = `America/New_York`)

1. **Deadline only**
   Input: `{"start_text":null,"end_text":"Nov 15","duration":"2h"}`
   LLM gets: `{"start_text":null,"end_text":"Nov 15"}`
   Output:

```json
{
  "start_text": "October 18, 2025 03:00 pm",
  "end_text":   "November 15, 2025 11:59 pm",
  "duration":   "2h"
}
```

2. **Start-only (tomorrow) - FIXED** ⭐
   Input: `{"start_text":"tomorrow","end_text":null,"duration":null}`
   LLM gets: `{"start_text":"tomorrow","end_text":null}`
   Output:

```json
{
  "start_text": "October 19, 2025 12:00 am",
  "end_text":   "October 19, 2025 11:59 pm",
  "duration":   null
}
```

3. **Duration-only case (CRITICAL)** ⭐
   Input: `{"start_text":null,"end_text":null,"duration":"2 hours"}`
   LLM gets: `{"start_text":null,"end_text":null}`
   Output:

```json
{
  "start_text": "October 18, 2025 03:00 pm",
  "end_text":   "October 18, 2025 11:59 pm",
  "duration":   "2 hours"
}
```

4. **Start + deadline**
   Input: `{"start_text":"Friday 8pm","end_text":"Friday 6pm","duration":null}`
   LLM gets: `{"start_text":"Friday 8pm","end_text":"Friday 6pm"}`
   Output:

```json
{
  "start_text": "October 24, 2025 08:00 pm",
  "end_text":   "October 25, 2025 06:00 pm",
  "duration":   null
}
```

---

## Key Improvements in v2 ⭐

1. **Duration Separation**: Duration is handled separately from start/end processing
2. **Tomorrow Fix**: Tomorrow now correctly defaults to 12:00 am instead of 9:00 am
3. **End Time Logic**: Start-only cases now set end to same date as start (11:59 pm)
4. **Duration-Only Cases**: Clear handling of duration-only scenarios
5. **Reduced Confusion**: Duration is not sent to LLM, preventing calculation errors
6. **Deterministic**: More predictable behavior with cleaner separation of concerns

These rules keep the Absolute Resolver **deterministic**, **explainable**, and perfectly aligned with the Slot Extractor's output—ready for your final **Window Formatter** step to convert to ISO and normalize duration.