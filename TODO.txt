LLM here must be ollama llama3

1. create smart LLM decomposer agent (can be multiple steps using Langgraph/Langchain) which takes the task, along with the deadline and smartly decides 
- which calendar to add the event to 
- break the event down into 2-5 subtasks and allot time needed for each subtask. One subtask cannot exceed 3 hours. If it is super simple - it can even not have a subtask.
- this returns ONLY substasks with time (in minutes) for each and None if no subtask.


2. time allotment agent [This part does not need an LLM]
thoroughly read info in task_scheduler/ folder to gauge what works how - this is going to be our scheduler.
- extract free time slots from the calendar till the deadline (holidays dont count as busy - so always exclude [snippet on how to do this below]), basically list events and then whatever time slots are free apart from those till the deadline can act as free slots. Make sure the format of the slots is maintained as per the input requirements.
- use the task_scheduler from task_scheduler/ to schedule the tasks.

small snippet to list events without holidays:
```
list next 30 days excluding holidays
import requests
from datetime import datetime

BASE = "http://127.0.0.1:8765"

events_30 = requests.get(f"{BASE}/events", params={"days": 30}, timeout=20).json()

def is_holiday(e):
    return "holiday" in (e.get("calendar") or "").lower()

filtered = [e for e in events_30 if not is_holiday(e)]

print(f"Found {len(filtered)} non-holiday events in next 30 days\n")
print(f"{'Start':<20} {'End':<20} {'Calendar':<14} Title")
print("-"*90)
for e in sorted(filtered, key=lambda x: x["start_iso"]):
    s = datetime.fromisoformat(e["start_iso"]).strftime("%Y-%m-%d %H:%M")
    en = datetime.fromisoformat(e["end_iso"]).strftime("%Y-%m-%d %H:%M")
    print(f"{s:<20} {en:<20} {str(e.get('calendar') or ''):<14} {e['title']}")
```
- have a test here to test if time slots are actually calculated till the deadline and not beyond.
- make sure the output from this step exactly matches the input structure of the api for CalBridge to create the event.

3. task scheduler and event creator:
- generate IDs for all events: event_id for every event. if an event has a parent (i.e it is a subtask) let it have a parent_id.
- create events with the details given from both steps (calendar type, subtasks(if any))
    - each subtask: must have parent id in notes; followed by any notes needed.
    - if no subtask: just store parent_id: NULL; followed by any notes needed.


4. have tests for each step. go slowly and have descriptive steps - easier to debug.

-------

updates to add:

- is adding constraints easy? does it work? have to figure out a way to translate memory into this and normal queries onto this.
- how to set deadline? can this be automated using an LLM?
- free slots working? done.